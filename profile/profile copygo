//Package profile профиль телеграм бота tdbot
package profile

import (
	"fmt"
	"log"
	"os"
	"strings"
	"tbot/internal/profile/config"
	"tbot/pkg/events/eventman"
	"tbot/pkg/user"
	"time"
)

//Profile ...
type Profile struct {
	User       *user.User
	Dir        string
	ConfigFile string
	Config     *config.Config
	Event      *eventman.Manager
}

const (
	EventTypeRequest  = "request"
	EventTypeResponse = "response"
	EventTypeError    = "error"
)

const (
	ErrorLimitExceeded = 604
	ErrorLimitNotSet   = 605
)

var defaultDir = ""

var (
	watchEventList = []string{"*"}

/*
	watchEventList = []string{
		"importContacts",
		"searchContacts",
		"sendMessage",
		"setName",
		"getUser",
		"createPrivateChat",
		"sendToNewUser",
		"createPrivateChat",
		"setAuthenticationPhoneNumber",
	}
*/
)

func newProfile(dir, name, phone string, usrType user.Type) *Profile {

	cfg := config.New()
	return &Profile{
		User:       user.New(name, phone, usrType),
		Dir:        dir,
		ConfigFile: "bot.toml",
		Config:     cfg,
		Event:      newEventManager(dir, watchEventList),
	}
}

func newEventManager(dir string, eventList []string) *eventman.Manager {
	return eventman.New(dir+"event", eventList)
}

// Load загрузить профиль бота
func Load(profileDir string, usrType user.Type, copyToProfile bool) (prof *Profile, err error) {

	addTail(&profileDir)

	phoneNumber := getPhoneNumber(profileDir)

	// Если указан номер телефона тогда инициализируем конкретный профиль, иначе подбираем готовый к работе из списка
	if phoneNumber != "" {
		makeProfileDir(profileDir)

		prof, err = New(profileDir, phoneNumber, phoneNumber, usrType, copyToProfile)
		if err != nil {
			return nil, err
		}

	} else {
		if prof = Find(profileDir, usrType, copyToProfile); prof == nil {
			//fmt.Println("Нет доступных профилей. Ожидаем....")
			time.Sleep(3 * time.Second)
			prof, _ = Load(profileDir, usrType, copyToProfile)
		}

	}

	return prof, nil
}

// New ...
func New(dir, name, phone string, usrType user.Type, copyToProfile bool) (prof *Profile, err error) {
	addTail(&dir)
	//блокируем профиль для избежания повторного использования
	err = LockProfileDir(dir)
	if err != nil {
		return nil, fmt.Errorf("Профиль уже используется")
	}

	prof = newProfile(dir, name, phone, usrType)
	prof.LoadConfig(copyToProfile)
	return prof, nil
}

// Find ...
func Find(dir string, usrType user.Type, copyToProfile bool) (prof *Profile) {
	var err error
	//ищем профиль в указанной директории
	profileList := getProfilesList(dir)

	for _, p := range profileList {
		dir := dir + p

		prof, err = New(dir, p, p, usrType, copyToProfile)
		if err != nil {
			continue
		}

		//если у профиля ограничения по лимитам тогда игнорируем его
		if prof.Config.APP.CheckLimit {
			_, err = prof.CheckAllLimits()
			if err != nil {
				prof.Event.Store.Close()
				UnlockProfileDir(dir)
				prof = nil
				fmt.Printf("Превышен лимит : %s\n", err)
				continue
			}

		}
		break
	}

	return prof
}

//LoadConfig найти и загрузить конфигурацию из файла
// @copy - копировать дефолтную конфигурацию в директорию профиля
func (p *Profile) LoadConfig(copy bool) error {

	var configDir string
	var err error

	//пробуем загрузить конфигурацию
	//Если copy то нужно загрузить дефолтную конфигурацию и скопировать ее в профиль
	if copy {
		configDir, err = p.Config.Load(p.ConfigFile, defaultDir)
	} else {
		configDir, err = p.Config.Load(p.ConfigFile, p.Dir, defaultDir)
	}

	if err != nil {
		return fmt.Errorf("Ошибка при загрузке файла конфигурации %s : %s", p.ConfigFile, err)
	}

	if configDir == p.Dir {
		p.ConfigFile = configDir + p.ConfigFile
		fmt.Printf("Настройки бота успешно загружены из %s\n", p.ConfigFile)
		return nil
	}

	fmt.Printf("Настройки бота успешно загружены из %s\n", configDir+p.ConfigFile)

	if copy && configDir != p.Dir {
		p.ConfigFile = p.Dir + p.ConfigFile
		//копируем найденую конфигурацию в профиль
		err = p.Config.Save(p.ConfigFile)
		if err != nil {
			fmt.Printf("Ошибка при сохранении конфигурации : %s", err)
			os.Exit(1)
		}
		fmt.Printf("Дефолтные настройки скопированы в %s\n", p.ConfigFile)
	} else {
		p.ConfigFile = configDir + p.ConfigFile
		fmt.Printf("Используется конфигурация %s\n", p.ConfigFile)
	}

	return nil
}

// CheckAllLimits проверить все лимиты
func (p *Profile) CheckAllLimits() (int, error) {

	for evType, eventList := range p.Config.Limits {
		for evName := range eventList {
			if ecode, err := p.CheckLimit(evType, evName); ecode == ErrorLimitExceeded {
				return ecode, err
			}

		}

	}

	return 0, nil

}

/*
// CheckLimits проверить все лимиты
func (p *Profile) CheckLimits() (int, error) {
	for _, eventName := range watchEventList {
		if ecode, err := p.CheckLimit(EventTypeError, eventName); ecode == ErrorLimitExceeded {
			return ecode, err
		}

		if ecode, err := p.CheckLimit(EventTypeRequest, eventName); ecode == ErrorLimitExceeded {
			return ecode, err
		}

		if ecode, err := p.CheckLimit(EventTypeResponse, eventName); ecode == ErrorLimitExceeded {
			return ecode, err
		}

	}

	return 0, nil

}
*/

// CheckLimit проверить достижение литов события
func (p *Profile) CheckLimit(evType, evName string) (int, error) {

	//Если для события не установлен лимит тогда проверку считаем удачной
	if p.Config == nil || p.Config.Limits == nil || p.Config.Limits[evType] == nil || p.Config.Limits[evType][evName] == nil {
		return 0, nil
	}

	for _, limit := range p.Config.Limits[evType][evName] {
		minTime := int32(time.Now().Unix()) - limit.Interval
		evns, err := p.Event.SearchByTime(evType, evName, minTime, 0)
		if err != nil {
			log.Fatalf("Search Event Error : %s\n", err)
			os.Exit(1)
			//continue
			//return 0, err
		}

		if len(evns) >= int(limit.Limit) {
			fmt.Printf("Limit exceeded %s - %s\n", evType, evName)
			return ErrorLimitExceeded, fmt.Errorf("%s:%s[%d:%d]", evType, evName, limit.Interval, limit.Limit)
			//data := fmt.Sprintf("%s:%s[%d:%d]", evType, evName, limit.Interval, limit.Limit)
			//return tdlib.NewError(ErrorLimitExceeded, "Limit exceeded", data)
		}
	}

	return 0, nil
}

// CheckDir проверяем наличие директории профиля
func (p *Profile) CheckDir() bool {
	_, err := os.Stat(p.Dir)
	if err == nil {
		return true
	}
	//if os.IsNotExist(err) {
	//		return false
	//	}
	return false
}

// BaseDir базавая директория профиля
func (p *Profile) BaseDir() string {
	base := strings.Replace(p.Dir, p.User.PhoneNumber+"/", "", 1)
	if base == "" {
		base = "./"
	}
	return base
}
